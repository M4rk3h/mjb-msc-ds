colWhichMax(Data$Tmax)
colWhichMax <- function(data) sapply(data, which.max)
colWhichMax(Data$Tmax)
# find max value
colMax <- function(data) sapply(data, max, na.rm = TRUE)
colMax(Data$Tmax) %>% which.max()
# East_Anglia has the highest temp within the Tmax series.
colMax(Data$Tmean) %>% which.max()
# find lowest value
colMin <- function(data) sapply(data, min, na.rm = TRUE)
colMin(Data$Tmax)
colMax(dTemp)
colMax(dTemp) %>% which.max()
colMax(dTemp) %>% which.min()
# East_Anglia has the highest temp within the Tmean series.
colMax(Data$Tmin)
# East_Anglia has the highest temp within the Tmean series.
colMax(Data$Tmin)%>% which.max()
# find lowest value
colMin <- function(data) sapply(data, min, na.rm = TRUE)
colMin(Data$Tmax)
colMin(Data$Tmax) %>% which.max()
# find lowest value
colMin <- function(data) sapply(data, min, na.rm = TRUE)
colMin(Data$Tmax) %>% which.max()
colMin(Data$Tmax)
colMin(Data$Tmax) %>% which.min()
colMin(Data$Tmax)
# Midlands has the lowest temp within the Tmax series.
colMin(Data$Tmean) %>% which.min()
# East_Anglia has the lowest temp within the Tmean series.
colMin(Data$Tmin)
# East_Anglia has the lowest temp within the Tmean series.
colMin(Data$Tmin) %>% which.min()
colMin(Data$Tmax) %>% which.min()
# Midlands has the lowest temp within the Tmax series.
colMin(Data$Tmean) %>% which.min()
colMin(Data$Tmean)
colMin(Data$Tmax) %>% which.min()
# Midlands has the lowest temp within the Tmax series.
colMin(Data$Tmean) %>% which.min()
# Scotland_E has the lowest temp within the Tmean series.
colMin(Data$Tmin) %>% which.min()
colRange(Data$Tmax)
colRange(Data$Tmax) %>% which()
colRange(Data$Tmax)
Data$Tmax %>% range()
Data$Tmax %>% sapply(data, range())
Data$Tmax %>% sapply(data, range)
sapply(Data$Tmax, range)
lapply(Data$Tmax, range)
Data$Tmax %>% range() %>% which.max()
largest_range <- function(id){
rbind(id,
(max(data$length[which(data$id == id)]) -
min(data$length[which(data$id == id)])))
}
lapply(X = unique(Data$Tmax), FUN = largest_range)
largest_range <- function(id){
rbind(id,
(max(data$length[which(data$id == id)]) -
min(data$length[which(data$id == id)])))
}
lapply(X = unique(Data$Tmax), FUN = largest_range)
colRange <- function(data) sapply(data, range, na.rm = TRUE)
colRange(Data$Tmax)
colRange(Data$Tmax)
colRange(Data$Tmax) %>% min()
( colRange(Data$Tmax) %>% min() ) - (colRange(Data$Tmax) %>% max())
colMins <- tapply(Data$Tmax, min)
colMins <- tapply(Data$Tmax, min)
colMins <- lapply(Data$Tmax, min)
colMins <- sapply(Data$Tmax, min)
colMax <- sapply(Data$Tmax, max)
colMins
colMax
colMins <- sapply(Data$Tmax, min)
colMax <- sapply(Data$Tmax, max)
unique ( Data$Tmax)[which.max(colMax - colMins]
colMins <- sapply(Data$Tmax, min)
colMax <- sapply(Data$Tmax, max)
unique ( Data$Tmax)[which.max(colMax - colMins)]
colMins <- sapply(Data$Tmax, min)
colMax <- sapply(Data$Tmax, max)
colMins
colMax
unique(Data$Tmax)[which.max(colMax - colMins)]
myRanges <- unique(Data$Tmax)[which.max(colMax - colMins)]
View(myRanges)
myRanges[[1]]
colRange(Data$Tmax) %>% unique(Data$Tmax)[which.max(colMax - colMins)]
colRange(Data$Tmax) %>% unique()[which.max(colMax - colMins)]
Data$Tmax %>%
colRange() %>%
unique()[which.max(colMax - colMins)]
Data$Tmax %>%
unique()[which.max(colMax - colMins)] %>%
colRange()
colRange <- function(data) sapply(data, range, na.rm = TRUE)
colRange(Data$Tmax)
colMax(dTemp) %>% which.min()
# unlist the data to check whole dataset
dTemp <-
Data %>%
unlist()
colMax(dTemp) %>% which.min()
# find max value
colMax <- function(data) sapply(data, max, na.rm = TRUE)
colMax(Data$Tmax) %>% which.max()
# East_Anglia has the highest temp within the Tmax series.
colMax(Data$Tmean) %>% which.max()
# East_Anglia has the highest temp within the Tmean series.
colMax(Data$Tmin) %>% which.max()
# find lowest value
colMin <- function(data) sapply(data, min, na.rm = TRUE)
colMin(Data$Tmax) %>% which.min()
# find lowest value
colMin <- function(data) sapply(data, min, na.rm = TRUE)
colMin(Data$Tmax) %>% which.min()
# Midlands has the lowest temp within the Tmax series.
colMin(Data$Tmean) %>% which.min()
# Scotland_E has the lowest temp within the Tmean series.
colMin(Data$Tmin) %>% which.min()
colRange <- function(data) sapply(data, range, na.rm = TRUE)
colRange(Data$Tmax)
# East_Anglia    has the lowest temp within the Tmax series.
colRange(Data$Tmean)
# East_Anglia    has the lowest temp within the Tmax series.
colRange(Data$Tmean)
# East_Anglia has the lowest temp within the Tmean series.
colRange(Data$Tmin)
# unlist the data to check whole dataset
dTemp <-
Data %>%
unlist()
colMax(dTemp) %>% which.min()
colMin(dTemp) %>% which.min()
colMax(dTemp) %>% which.max()
colMin(dTemp) %>% which.min()
colRange(dTemp) %>% which.min()
# highest temp
colMax(dTemp) %>% which.max()
# lowest temp
colMin(dTemp) %>% which.min()
colMin(Data$Tmax) %>% which.min()
colMin(Data$Tmax)
colMin(Data$Tmax) %>% which.min()
# lowest temp
colMin(dTemp) %>% which.min()
colMin(Data$Tmax)
colMin(Data$Tmax) %>% which.min()
colMax(dTemp) %>% which.max()
colMin(dTemp) %>% which.min()
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1 - Task 1
library(magrittr)
library(tseries)
# set seed
set.seed(17076749)
# set address
address <- "https://www.metoffice.gov.uk/pub/data/weather/uk/climate/datasets/"
# set features
features <- c("Tmax", "Tmean", "Tmin")
# create a list of districts
districts <- c("Northern_Ireland",
"Scotland_N",
"Scotland_E",
"Scotland_W",
"England_E_and_NE",
"England_NW_and_N_Wales",
"Midlands",
"East_Anglia",
"England_SW_and_S_Wales",
"England_SE_and_Central_S")
# how many rows
nrow <- 2020-1884+1
# Time Series function
create.ts <- function(feature, district){ # pass 2 parameters
c(address, feature, "/date/", district, ".txt") %>%  # set the url with several features adding 2 text fields
paste(collapse = "") %>%  # collapse the set urls above with no space
read.table(skip = 5, header = TRUE, nrows = nrow) %>%  # read the table, skip 5 rows, add first col as headers and nrows is 2020-1884+1
subset(select = 2:13) %>%  # only select Jan - Dec
t() %>% # transpose matrix
as.vector() %>% # save it as a vector
ts(start = c(1884, 1),frequency = 12) # create a time-series object
}
# test the function
create.ts("Tmax", "Northern_Ireland")
# function to get all districts & features
readFeatures <- function(feature){
lapply(districts, create.ts, feature = feature) %>%
set_names(districts)
}
# get them all together.
Data <- lapply(features, readFeatures) %>% set_names(features)
# select the Tmax from Northern_Ireland
Data$Tmax$Northern_Ireland
colMax <- lapply(features, colMax)
# find max value
colMax <- function(data) sapply(data, max, na.rm = TRUE)
colMax <- lapply(features, colMax)
colMax
View(colMax)
colMax[[1]]
colMax <- sapply(features, colMax)
colMax
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1 - Task 1
library(magrittr)
library(tseries)
# set seed
set.seed(17076749)
# set address
address <- "https://www.metoffice.gov.uk/pub/data/weather/uk/climate/datasets/"
# set features
features <- c("Tmax", "Tmean", "Tmin")
# create a list of districts
districts <- c("Northern_Ireland",
"Scotland_N",
"Scotland_E",
"Scotland_W",
"England_E_and_NE",
"England_NW_and_N_Wales",
"Midlands",
"East_Anglia",
"England_SW_and_S_Wales",
"England_SE_and_Central_S")
# how many rows
nrow <- 2020-1884+1
# Time Series function
create.ts <- function(feature, district){ # pass 2 parameters
c(address, feature, "/date/", district, ".txt") %>%  # set the url with several features adding 2 text fields
paste(collapse = "") %>%  # collapse the set urls above with no space
read.table(skip = 5, header = TRUE, nrows = nrow) %>%  # read the table, skip 5 rows, add first col as headers and nrows is 2020-1884+1
subset(select = 2:13) %>%  # only select Jan - Dec
t() %>% # transpose matrix
as.vector() %>% # save it as a vector
ts(start = c(1884, 1),frequency = 12) # create a time-series object
}
# test the function
create.ts("Tmax", "Northern_Ireland")
# function to get all districts & features
readFeatures <- function(feature){
lapply(districts, create.ts, feature = feature) %>%
set_names(districts)
}
# get them all together.
Data <- lapply(features, readFeatures) %>% set_names(features)
# select the Tmax from Northern_Ireland
Data$Tmax$Northern_Ireland
# find the max value's index
maxIndex <- Data$Tmax %>%
unlist() %>%
as.vector() %>%
which.max()
# find sub position
subIndex <- round((maxIndex/16440)*10) # 8 - This could be district
# GETS MONTH
unlistedTMAX <- Data$Tmax %>% unlist()
myMm <- month.abb[(time(unlistedTMAX)[which.min(unlistedTMAX)] %% 1)*12+1]
# get max temp of Tmax
sapply(Data$Tmax, which.max)
# unlist tMAX
tmax_unl <- Data$Tmax %>%
unlist() %>%
as.vector()
# find max value
colMax <- function(data) sapply(data, max, na.rm = TRUE)
colMax(Data$Tmax) %>% which.max()
# East_Anglia has the highest temp within the Tmax series.
colMax(Data$Tmean) %>% which.max()
# East_Anglia has the highest temp within the Tmean series.
colMax(Data$Tmin) %>% which.max()
# find lowest value
colMin <- function(data) sapply(data, min, na.rm = TRUE)
colMin(Data$Tmax) %>% which.min()
# Midlands has the lowest temp within the Tmax series.
colMin(Data$Tmean) %>% which.min()
# Scotland_E has the lowest temp within the Tmean series.
colMin(Data$Tmin) %>% which.min()
colRange <- function(data) sapply(data, range, na.rm = TRUE)
colRange(Data$Tmax)
colRange(Data$Tmean)
colRange(Data$Tmin)
# The above can also be done on the full dataset.
maxTemps <- sapply(Data, colMax)
minTemps <- sapply(Data, colMin)
totRange <- sapply(Data, colRange)
totRange %>% which.max()
maxTemps
minTemps
totRange
totRange %>% which.max()
# The above can also be done on the full dataset.
maxTemps <- sapply(Data, colMax)
maxTemps
minTemps <- sapply(Data, colMin)
minTemps
totRange <- sapply(Data, colRange)
totRange
maxTemps
plot(maxTemps)
require(graphics)
ts.plot(ldeaths, mdeaths, fdeaths,
gpars=list(xlab="year", ylab="deaths", lty=c(1:3)))
maxTemps$Tmax
ts.plot(maxTemps,
gpars=list(xlab="year", ylab="deaths", lty=c(1:3)))
plot(maxTemps, type='l')
plot(Data$Tmax, type='l')
plot(Data$Tmax)
ts.plot(maxTemps,
gpars=list(xlab="year", ylab="deaths", lty=c(1:3)))
print(maxTemps)
# The above can also be done on the full dataset.
maxTemps <- sapply(Data, colMax)
# print
maxTemps
minTemps <- sapply(Data, colMin)
# print
minTemps
totRange <- sapply(Data, colRange)
# print
totRange
# print
maxTemps
View(maxTemps)
# print
is.vector(maxTemps)
# print
is.data.frame(maxTemps)
typeof(maxTemps)
# print
is.double(maxTemps)
# print
testV <- as.vector(maxTemps)
# print
maxTemps
# create a function that accepts as arguments a time series dataset
# and the kind of model that we want to create (linear, quadratic, cubic,...)
# and gives as output the model with given parameters
create.model <- function(timeseries, degree) {
# degree vector
degree.vect = c(1,2,3)
# create a switch case
degree.value <- switch(degree,
linear    = degree.vect[1],
quadratic = degree.vect[2],
cubic     = degree.vect[3])
#
c(timeseries,
c("poly(time,",
as.character(degree.value),
", raw = TRUE)") %>% paste(collapse = "")) %>%
paste(collapse = " ~ ") %>%
as.formula() %>%
lm() -> model
# return
return(model %>% fitted())
}
create.model(Data, 1)
create.model(Data$Tmax$Scotland_N, 1)
plot(globaltemps, type = 'l')
lines(create.model("globaltemps", "linear"),    col = 'green',  lwd = 3)
lines(create.model("globaltemps", "quadratic"), col = 'purple', lwd = 3)
lines(create.model("globaltemps", "cubic"),     col = 'red',    lwd = 3)
time.set <- 1:length(Data$Tmax$England_SW_and_S_Wales)
# double check it.
length(time.set)
# create a linear fit of the dataset with the time.
linear.fit <- lm(Data$Tmax$England_SW_and_S_Wales ~ time.set)
summary(linear.fit) #
# rescale the time vector
time <- 1:length(Data$Tmax$England_SW_and_S_Wales)
time <- (time - min(time)) / (max(time) -1)
# try again with rescaled
linear.fit <- lm(Data$Tmax$England_SW_and_S_Wales ~ time)
summary(linear.fit) #
print(1.0500 * 12)
ts.plot(Data$Tmax$England_SW_and_S_Wales, ylab = "Temperature")
linear.fit %>% fitted() %>% ts(start = 1884, frequency = 12) -> linear.fitted
lines(linear.fitted, col = "green", lwd = 2)
abline(mean(Data$Tmax$England_SW_and_S_Wales), 0, col = "blue", lwd = 2)
# lets look at the last 10 years
ts.plot(Data$Tmax$England_SW_and_S_Wales[1524:1644],
ylab = "Temperature")
lines(linear.fitted[1524:1644],
col = "green",
lwd = 2)
abline(mean(Data$Tmax$England_SW_and_S_Wales[1524:1644]),
0,
col = "blue",
lwd = 2)
tempMaxOneSlice <- Data$Tmax$England_SW_and_S_Wales[1:120] %>%
plot(type = 'l',
ylab = 'Max Temps - SW England / S Wales')
mean(Data$Tmax$England_SW_and_S_Wales[1:120]) # 12.46
# last 10 years recorded
tempMaxOneSlice2 <- Data$Tmax$England_SW_and_S_Wales[1524:1644] %>%
plot(type = 'l',
ylab = 'Max Temps - SW England / S Wales')
mean(Data$Tmax$England_SW_and_S_Wales[1524:1644]) # 13.82
# now the first 10 years
ts.plot(Data$Tmax$England_SW_and_S_Wales[1:120],
ylab = "Temperature")
lines(linear.fitted[1:120],
col = "green",
lwd = 2)
abline(mean(Data$Tmax$England_SW_and_S_Wales[1:120]),
0,
col = "blue",
lwd = 2)
time.set <- 1:length(Data$Tmax$England_SW_and_S_Wales)
# double check it.
length(time.set)
View(Data)
View(Data)
Data[["Tmax"]][["Northern_Ireland"]]
2020-1884
2019-1884
time.set <- 1:length(Data$Tmax$England_SW_and_S_Wales - 1)
# double check it.
length(time.set)
slicedDF <- Data$Tmax$England_SW_and_S_Wales - 1
slicedDF
foot(slicedDF)
slicedDF <- Data$Tmax$England_SW_and_S_Wales - 2
slicedDF <- Data$Tmax$England_SW_and_S_Wales - 1
slicedDF
# find max value
colMax <- function(data) sapply(data, max, na.rm = TRUE)
colMax(Data$Tmax) %>% which.max()
# East_Anglia has the highest temp within the Tmax series.
colMax(Data$Tmean) %>% which.max()
# East_Anglia has the highest temp within the Tmean series.
colMax(Data$Tmin) %>% which.max()
# print
maxTemps
# print
totRange
colAvg <- function(data) sapply(data, mean(data))
colAvg(Data)
sapply(Data, colAvg)
colAvg <- function(data) sapply(data, mean())
sapply(Data, colAvg)
Data %>% mean()
sapply(Data %>% mean())
sapply(Data, mean)
sapply(Data, mean())
sapply(Data, mean
)
colAvg <- function(data) sapply(data, mean)
Data %>% mean.list()
mean(as.numeric(levels(c1$Var1)))
mean(as.numeric(levels(Data)))
mean(as.numeric(levels(Data$Tmax)))
mean(as.numeric(levels(Data$Tmax$Northern_Ireland)))
mean(as.numeric(Data$Tmax$Northern_Ireland))
mean(as.numeric(Data$Tmax$))
mean(as.numeric(Data$Tmax))
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1 - Task 1
library(magrittr)
library(tseries)
source('~/GitHub/mjb-msc-ds/data-mining-and-statistical-modelling/assessment-2/meeting-notes.R')
?Startup
Sys.getenv()
print(Sys.setenv(R_TEST = "testit", "A+C" = 123))
save.image("~/GitHub/mjb-msc-ds/data-mining-and-statistical-modelling/assessment-2/updated-notes.RData")
load("~/GitHub/mjb-msc-ds/data-mining-and-statistical-modelling/assessment-2/updated-notes.RData")
library(magrittr)
foo_foo <- little_bunny()
library(magrittr)
foo_foo <- little_bunny()
foo_foo_1 <- hop(foo_foo, through = forest)
foo_foo_2 <- scoop(foo_foo_1, up = field_mice)
foo_foo_3 <- bop(foo_foo_2, on = head)
foo_foo <- little_bunny()
library(magrittr)
diamonds <- ggplot2::diamonds
diamonds2 <- diamonds %>%
dplyr::mutate(price_per_carat = price / carat)
source('~/.active-rstudio-document', echo=TRUE)
pryr::object_size(diamonds)
source('~/.active-rstudio-document', echo=TRUE)
pryr::object_size()
getMean <- function(x){
is.na() %>% mean()
}
getMean(x)
x <- c(1:10, Inf)
mean(is.na(x))
x <- c(1:10)
mean(is.na(x))
getMean <- function(x){
is.na() %>% mean()
}
getMean(x)
getMean <- function(x){
is.na(x) %>% mean(x)
}
getMean(x)
getMyX <- function(x){
x / sum(x, na.rm=T)
}
getMyX(x)
x / sum(x, na.rm = TRUE)
commas(letters, collapse = "-")
install.packages("mdsr")
source('~/GitHub/mjb-msc-ds/data-mining-and-statistical-modelling/assessment-2/meeting-notes.R')
source('~/GitHub/mjb-msc-ds/data-mining-and-statistical-modelling/assessment-2/meeting-notes.R')
library(tidyverse)
