t() %>%
as.vector()
}
testTS <- lapply(Data, matCon)
is.vector(testTS)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# function to slice dataset
slice.ts <- function(data){
data %>% window(start = c(1884,12),
end = c(2019,12),
frequency = 12,
extend = FALSE)
}
# use fun for each dataset.
slicedWindow <-
slice.ts(Data$Tmax$England_SE_and_Central_S)
# 4.1 - Estimate Trend
# Estimate the trend of each time series using linear, quadratic and cubic
# regression. Compare your results and use appropriate plots and/or tables
# to confirm your observations.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# create time vector
# create a time vector
time <- 1:length(slicedWindow)
# re-scale from 0 - 1
time <- (time - min(time))/(max(time) - 1)
# function for linear model
linear.fun <- function(timeseries){
# create linear trend
linear.fit <<- lm(timeseries ~ time) # use <<- for global variables
# create linear fitted
linear.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->> linear.fitted
}
# run linear fun
linear.fun(slicedWindow)
# check summary
# summary(linear.fit)
# Now try to plot
ts.plot(slicedWindow, ylab = "Temperature")
# add linear fitted lines
lines(linear.fitted, col = "green", lwd = 2)
# add mean line
abline(mean(slicedWindow), 0, col = "blue", lwd = 2)
# temp is very slowly increasing.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# square the time
time2 <- (time^2)
# quadratic trend
quadratic.fun <- function(timeseries){
# create quadratic fit model
quadratic.fit <<- lm(timeseries ~ time + time2)
# create quadratic fitted
quadratic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run quad function
quadratic.fun(slicedWindow)
# check summary
# summary(quadratic.fit)
# add linear fitted lines
lines(quadratic.fitted, col = "green", lwd = 2)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# cube time
time3 <- time^3
# cubic function
cube.fun <- function(timeseries){
# create cubic fit model
cubic.fit <<- lm(timeseries ~ time + time2 + time3)
# create cubic fitted
cubic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run cubic function
cube.fun(slicedWindow)
# check summary
# summary(cubic.fit)
# add cubic line
lines(time,
cubic.fit %>% fitted(),
col = 'yellow',
lwd = 3)
# check fit
AIC(linear.fit)
AIC(quadratic.fit)
AIC(cubic.fit)
# 4.2 - Select Trend
# Select a trend model for each time series using an appropriate criteria.
# Are the models selected all the same? If not is there a pattern depending on
# the region and/or the group (max, mean and min)?
# All datasets had a lower AIC result for linear fit,
# except for TMAX-England_SE_and_Central_S
# 4.3 - Estimate Seasonality
# After removing the trend using the model selected in the previous step,
# use the output to estimate the seasonality of each time series employing averaging and sine-cosine models.
# Compare your results and use appropriate plots and/or tables to confirm your observations.
get.seasonality <- function(timeseries){
# get the residuals
sw.notrend <<- (timeseries - fitted(linear.fit))
# get seasonal means
tapply(sw.notrend, cycle(sw.notrend), mean)
# create months variable as factor
months <- sw.notrend %>% cycle() %>% as.factor()
# seasonal means
sliced.seas <<- lm(sw.notrend ~ months - 1)
# evaluate harmonic seasonality
# create an empty matrix
SIN <<- COS <<-  matrix(nrow = length(time), ncol = 6)# 6 = freq/2
# loop through
for(i in 1:6){
SIN[,i] <- sin(2*pi*i*time)
COS[,i] <- cos(2*pi*i*time)
}
# model all season harmonic
# model notrend against all values with -1
slice.har1 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1], COS = COS[,1]))
# slice 2
slice.har2 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:2], COS = COS[,1:2]))
# slice 3
slice.har3 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:3], COS = COS[,1:3]))
# slice 4
slice.har4 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:4], COS = COS[,1:4]))
# slice 5
slice.har5 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:5], COS = COS[,1:5]))
# slice 6
slice.har6 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:6], COS = COS[,1:6]))
}
# run seasonality fun
get.seasonality(slicedWindow)
getAIC <- data.frame(
slice.har.1 = AIC(slice.har1),
slice.har.2 = AIC(slice.har2),
slice.har.3 = AIC(slice.har3),
slice.har.4 = AIC(slice.har4),
slice.har.5 = AIC(slice.har5),
slice.har.6 = AIC(slice.har6)
)
# print with knitr table
kable(getAIC, caption = "AIC's for all harmonic seasonalities")
# sort decreasing
getAIC %>% sort(decreasing = F)
#summary(slice.har1)
#summary(slice.har2)
#summary(slice.har3)
#summary(slice.har4)
#summary(slice.har5)
#summary(slice.har6)
# removed as it doesnt work.
# plot(slicedWindow,
#      main = "AVG TEMPS IN UK",
#      xlab = "Year",
#      ylab = "AVG TEMP",
#      type = "l")
# lines doesnt work for some reason.
# lines(time,
#       fitted(slice.har2),
#       lwd = 3,
#       type = "l",
#       col = "blue")
# 4.4 - Select Seasonality
# Select a seasonal model for each time series using an appropriate criteria.
# Are the models selected all the same?
# If not is there a pattern depending on the region and/or the group (max, min and mean)?
# 4.5 - Estimate Seasonality
# Estimate a combined model for trend and seasonality using the results of the previous steps.
# Call this model “final”.
# 4.6 - Estimate Seasonality
# Estimate trend and seasonality using a combined quadratic and sin-cosine (of order 2) models.
# Call this model “test”
final.model <- lm(slicedWindow ~ .,
data.frame(TIME = poly(time, 1, raw =TRUE),
SIN = SIN[,c(1,2,4)],
COS = COS[,1:3]))
final.model <- lm(slicedWindow ~ .,
data.frame(TIME = poly(time, 1, raw =TRUE),
SIN = SIN[,c(1)],
COS = COS[,1]))
summary(final.model)
library(magrittr)
library(tseries)
library(knitr)
# set address
address <- "https://www.metoffice.gov.uk/pub/data/weather/uk/climate/datasets/"
# set features
features <- c("Tmax", "Tmean", "Tmin")
# create a list of districts
districts <- c("Northern_Ireland",
"Scotland_N",
"Scotland_E",
"Scotland_W",
"England_E_and_NE",
"England_NW_and_N_Wales",
"Midlands",
"East_Anglia",
"England_SW_and_S_Wales",
"England_SE_and_Central_S")
# how many rows
nrow <- 2020-1884+1
# Time Series function
create.ts <- function(feature, district){ # pass 2 parameters
c(address, feature, "/date/", district, ".txt") %>%  # set the url with several features adding 2 text fields
paste(collapse = "") %>%  # collapse the set urls above with no space
read.table(skip = 5, header = TRUE, nrows = nrow) %>%  # read the table, skip 5 rows, add first col as headers and nrows is 2020-1884+1
subset(select = 2:13) %>%  # only select Jan - Dec
t() %>% # transpose matrix
as.vector() %>% # save it as a vector
ts(start = c(1884, 1),frequency = 12) # create a time-series object
}
# test the function
create.ts("Tmax", "Northern_Ireland")
# function to get all districts & features
readFeatures <- function(feature){
lapply(districts, create.ts, feature = feature) %>%
set_names(districts)
}
# get them all together.
Data <- lapply(features, readFeatures) %>% set_names(features)
Data$Tmax$Northern_Ireland %>% head()
# 2 - Task 2
# find the max value's index
maxIndex <- Data$Tmax %>%
unlist() %>%
as.vector() %>%
which.max()
# find sub position
subIndex <- round((maxIndex/16440)*10) # 8 - This could be district
# find max value
# maxVal <- DTmUn %>% which.max()
# find year
# maxYear <- floor(time(DTmUn))[which.max(DTmUn)]
# month
# maxMonth <- month.abb[(time(Data$Tmax)[which.max(Data$Tmax)] %>% 1)*12+1]
# calculate regions
# maxRegions <- names(Data$Tmax)
# GETS MONTH
unlistedTMAX <- Data$Tmax %>% unlist()
myMm <- month.abb[(time(unlistedTMAX)[which.min(unlistedTMAX)] %% 1)*12+1]
# plot(Data$Tmax$Northern_Ireland, type = 'l')
# get max temp of Tmax
sapply(Data$Tmax, which.max)
# data_min_value_time <- time(Data)[which.min(Data)]
# unlist tMAX
tmax_unl <- Data$Tmax %>%
unlist() %>%
as.vector()
# find max value
colMax <- function(data) sapply(data, max, na.rm = TRUE)
colMax(Data$Tmax) %>% which.max()
# East_Anglia has the highest temp within the Tmax series
colMax(Data$Tmean) %>% which.max()
# East_Anglia has the highest temp within the Tmean series.
colMax(Data$Tmin) %>% which.max()
# England_SE_and_Central_S has the highest temp within Tmin.
# find lowest value
colMin <- function(data) sapply(data, min, na.rm = TRUE)
colMin(Data$Tmax) %>% which.min()
# Midlands has the lowest temp within the Tmax series.
colMin(Data$Tmean) %>% which.min()
# Scotland_E has the lowest temp within the Tmean series.
colMin(Data$Tmin) %>% which.min()
# Scotland_E has the lowest temp within the Tmin series
colRange <- function(data) sapply(data, range, na.rm = TRUE)
colRange(Data$Tmax)
colRange(Data$Tmean)
colRange(Data$Tmin)
# The above can also be done on the full dataset.
maxTemps <- sapply(Data, colMax)
minTemps <- sapply(Data, colMin)
totRange <- sapply(Data, colRange)
maxTemps
minTemps
totRange
colAvg <- function(data) sapply(data, mean)
sapply(Data, colAvg)
## NONE OF THIS WORKS
# Time Series function
convert.ts <- function(data, feature, district){ # pass 3 parameters
c(data, feature, districts) %>%
paste(collapse = "$") # add $ between each parameter
}
matrix.ts <- function(feature){
lapply(data, convert.ts, feature = feature, district = districts)
}
tsMatrix <- matrix.ts(Data)
matCon <- function(data){
data %>%
t() %>%
as.vector()
}
testTS <- lapply(Data, matCon)
is.vector(testTS)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# function to slice dataset
slice.ts <- function(data){
data %>% window(start = c(1884,12),
end = c(2019,12),
frequency = 12,
extend = FALSE)
}
# use fun for each dataset.
slicedWindow <-
slice.ts(Data$Tmax$England_SE_and_Central_S)
# 4.1 - Estimate Trend
# Estimate the trend of each time series using linear, quadratic and cubic
# regression. Compare your results and use appropriate plots and/or tables
# to confirm your observations.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# create time vector
# create a time vector
time <- 1:length(slicedWindow)
# re-scale from 0 - 1
time <- (time - min(time))/(max(time) - 1)
# function for linear model
linear.fun <- function(timeseries){
# create linear trend
linear.fit <<- lm(timeseries ~ time) # use <<- for global variables
# create linear fitted
linear.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->> linear.fitted
}
# run linear fun
linear.fun(slicedWindow)
# check summary
# summary(linear.fit)
# Now try to plot
ts.plot(slicedWindow, ylab = "Temperature")
# add linear fitted lines
lines(linear.fitted, col = "green", lwd = 2)
# add mean line
abline(mean(slicedWindow), 0, col = "blue", lwd = 2)
# temp is very slowly increasing.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# square the time
time2 <- (time^2)
# quadratic trend
quadratic.fun <- function(timeseries){
# create quadratic fit model
quadratic.fit <<- lm(timeseries ~ time + time2)
# create quadratic fitted
quadratic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run quad function
quadratic.fun(slicedWindow)
# check summary
# summary(quadratic.fit)
# add linear fitted lines
lines(quadratic.fitted, col = "green", lwd = 2)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# cube time
time3 <- time^3
# cubic function
cube.fun <- function(timeseries){
# create cubic fit model
cubic.fit <<- lm(timeseries ~ time + time2 + time3)
# create cubic fitted
cubic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run cubic function
cube.fun(slicedWindow)
# check summary
# summary(cubic.fit)
# add cubic line
lines(time,
cubic.fit %>% fitted(),
col = 'yellow',
lwd = 3)
# check fit
AIC(linear.fit)
AIC(quadratic.fit)
AIC(cubic.fit)
# 4.2 - Select Trend
# Select a trend model for each time series using an appropriate criteria.
# Are the models selected all the same? If not is there a pattern depending on
# the region and/or the group (max, mean and min)?
# All datasets had a lower AIC result for linear fit,
# except for TMAX-England_SE_and_Central_S
# 4.3 - Estimate Seasonality
# After removing the trend using the model selected in the previous step,
# use the output to estimate the seasonality of each time series employing averaging and sine-cosine models.
# Compare your results and use appropriate plots and/or tables to confirm your observations.
get.seasonality <- function(timeseries){
# get the residuals
sw.notrend <<- (timeseries - fitted(linear.fit))
# get seasonal means
tapply(sw.notrend, cycle(sw.notrend), mean)
# create months variable as factor
months <- sw.notrend %>% cycle() %>% as.factor()
# seasonal means
sliced.seas <<- lm(sw.notrend ~ months - 1)
# evaluate harmonic seasonality
# create an empty matrix
SIN <<- COS <<-  matrix(nrow = length(time), ncol = 6)# 6 = freq/2
# loop through
for(i in 1:6){
SIN[,i] <- sin(2*pi*i*time)
COS[,i] <- cos(2*pi*i*time)
}
# model all season harmonic
# model notrend against all values with -1
slice.har1 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1], COS = COS[,1]))
# slice 2
slice.har2 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:2], COS = COS[,1:2]))
# slice 3
slice.har3 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:3], COS = COS[,1:3]))
# slice 4
slice.har4 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:4], COS = COS[,1:4]))
# slice 5
slice.har5 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:5], COS = COS[,1:5]))
# slice 6
slice.har6 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:6], COS = COS[,1:6]))
}
# run seasonality fun
get.seasonality(slicedWindow)
getAIC <- data.frame(
slice.har.1 = AIC(slice.har1),
slice.har.2 = AIC(slice.har2),
slice.har.3 = AIC(slice.har3),
slice.har.4 = AIC(slice.har4),
slice.har.5 = AIC(slice.har5),
slice.har.6 = AIC(slice.har6)
)
# print with knitr table
kable(getAIC, caption = "AIC's for all harmonic seasonalities")
# sort decreasing
getAIC %>% sort(decreasing = F)
#summary(slice.har1)
#summary(slice.har2)
#summary(slice.har3)
#summary(slice.har4)
#summary(slice.har5)
#summary(slice.har6)
# removed as it doesnt work.
# plot(slicedWindow,
#      main = "AVG TEMPS IN UK",
#      xlab = "Year",
#      ylab = "AVG TEMP",
#      type = "l")
# lines doesnt work for some reason.
# lines(time,
#       fitted(slice.har2),
#       lwd = 3,
#       type = "l",
#       col = "blue")
final.model <- lm(slicedWindow ~ .,
data.frame(TIME = poly(time, 1, raw =TRUE),
SIN = SIN[,c(1)],
COS = COS[,1]))
final.model <- lm(slicedWindow ~ .,
data.frame(TIME = poly(time, degree = 1, raw = T),
SIN = SIN[,1:2],
COS = COS[,1]))
final.model <- lm(slicedWindow ~ ., data.frame(TIME = poly(time, degree = 1, raw = T),
SIN = SIN[,1:2],
COS = COS[,1]))
adf.test(residuals)
adf.test(residuals)
adf.test(slicedWindow)
milk.final <- lm(slicedWindow ~ .,
data.frame(TIME = poly(time, degree = 1, raw = T),
SIN = SIN[,1:2],
COS = COS[,1]))
library(tidyverse)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
median(df$a)
median(df$b)
median(df$c)
median(df$d)
# use loops
output <- vector("double", ncol(df))  # 1. output
for (i in seq_along(df)) {            # 2. sequence
output[[i]] <- median(df[[i]])      # 3. body
}
output
y <- vector("double", 0)
seq_along(y)
#> integer(0)
1:length(y)
mtcars %>% head()
mtOut <- vector("double", ncol(df))  # 1. output
mtOut <- vector("double", ncol(df1))  # 1. output
for (i in mtcars(df1)){
mtOut[[i]] <- median(df1[[i]])
}
df1 <- mtcars
mtOut <- vector("double", ncol(df1))  # 1. output
for (i in mtcars(df1)){
mtOut[[i]] <- median(df1[[i]])
}
mtOut <- vector("double", ncol(df1))  # 1. output
for (i in df1){
mtOut[[i]] <- median(df1[[i]])
}
df1
install.packages(c("broom", "cli", "cpp11", "crayon", "data.table", "dbplyr", "desc", "dplyr", "farver", "forcats", "formatR", "FSelector", "gert", "ggforce", "ggraph", "ggsignif", "htmltools", "isoband", "ISOcodes", "knitr", "lifecycle", "lubridate", "maptools", "MASS", "Matrix", "MatrixModels", "matrixStats", "memoise", "mgcv", "mime", "NCA", "nlme", "pbkrtest", "pillar", "pkgload", "promises", "ps", "quantreg", "rappdirs", "RcppArmadillo", "RcppParallel", "reprex", "rio", "rmarkdown", "rstatix", "rvest", "skimr", "SparseM", "stopwords", "survival", "testthat", "tibble", "tidyr", "tinytex", "topicmodels", "usethis", "utf8", "waldo", "withr", "xfun", "XML", "zoo"))
install.packages(c("broom", "callr", "caTools", "cli", "cpp11", "diffobj", "e1071", "gert", "gh", "mdsr", "processx", "remotes", "reprex", "styler", "tinytex", "tweenr", "vctrs", "XML"))
