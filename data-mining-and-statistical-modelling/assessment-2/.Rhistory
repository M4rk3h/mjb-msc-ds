# to confirm your observations.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# create time vector
# create a time vector
time <- 1:length(slicedWindow)
# re-scale from 0 - 1
time <- (time - min(time))/(max(time) - 1)
# function for linear model
linear.fun <- function(timeseries){
# create linear trend
linear.fit <<- lm(timeseries ~ time) # use <<- for global variables
# create linear fitted
linear.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->> linear.fitted
}
# run linear fun
linear.fun(slicedWindow)
# check summary
summary(linear.fit)
# Now try to plot
ts.plot(slicedWindow, ylab = "Temperature")
# add linear fitted lines
lines(linear.fitted, col = "green", lwd = 2)
# add mean line
abline(mean(slicedWindow), 0, col = "blue", lwd = 2)
# temp is very slowly increasing.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# square the time
time2 <- (time^2)
# quadratic trend
quadratic.fun <- function(timeseries){
# create quadratic fit model
quadratic.fit <<- lm(timeseries ~ time + time2)
# create quadratic fitted
quadratic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run quad function
quadratic.fun(slicedWindow)
# check summary
summary(quadratic.fit)
# add linear fitted lines
lines(quadratic.fitted, col = "green", lwd = 2)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# cube time
time3 <- time^3
# cubic function
cube.fun <- function(timeseries){
# create cubic fit model
cubic.fit <<- lm(timeseries ~ time + time2 + time3)
# create cubic fitted
cubic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run cubic function
cube.fun(slicedWindow)
# check summary
summary(cubic.fit)
# add cubic line
lines(time,
cubic.fit %>% fitted(),
col = 'yellow',
lwd = 3)
# check fit
AIC(linear.fit)
AIC(quadratic.fit)
AIC(cubic.fit)
# 4.2 - Select Trend
# Select a trend model for each time series using an appropriate criteria.
# Are the models selected all the same? If not is there a pattern depending on
# the region and/or the group (max, mean and min)?
# All datasets had a lower AIC result for linear fit,
# except for TMAX-England_SE_and_Central_S
# 4.3 - Estimate Seasonality
# After removing the trend using the model selected in the previous step,
# use the output to estimate the seasonality of each time series employing averaging and sine-cosine models.
# Compare your results and use appropriate plots and/or tables to confirm your observations.
get.seasonality <- function(timeseries){
# get the residuals
sw.notrend <<- (timeseries - fitted(linear.fit))
# get seasonal means
tapply(sw.notrend, cycle(sw.notrend), mean)
# create months variable as factor
months <<- sw.notrend %>% cycle() %>% as.factor()
# seasonal means
sliced.seas <<- lm(sw.notrend ~ months - 1)
# evaluate harmonic seasonality
# create an empty matrix
SIN <<- COS <<-  matrix(nrow = length(time), ncol = 6)# 6 = freq/2
# loop through
for(i in 1:6){
SIN[,i] <- sin(2*pi*i*time)
COS[,i] <- cos(2*pi*i*time)
}
# model all season harmonic
# model notrend against all values with -1
slice.har1 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1], COS = COS[,1]))
# slice 2
slice.har2 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:2], COS = COS[,1:2]))
# slice 3
slice.har3 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:3], COS = COS[,1:3]))
# slice 4
slice.har4 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:4], COS = COS[,1:4]))
# slice 5
slice.har5 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:5], COS = COS[,1:5]))
# slice 6
slice.har6 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:6], COS = COS[,1:6]))
}
# run seasonality fun
get.seasonality(slicedWindow)
# 4.3 - Estimate Seasonality
# After removing the trend using the model selected in the previous step,
# use the output to estimate the seasonality of each time series employing averaging and sine-cosine models.
# Compare your results and use appropriate plots and/or tables to confirm your observations.
get.seasonality <- function(timeseries){
# get the residuals
sw.notrend <<- (timeseries - fitted(linear.fit))
# get seasonal means
tapply(sw.notrend, cycle(sw.notrend), mean)
# create months variable as factor
months <- sw.notrend %>% cycle() %>% as.factor()
# seasonal means
sliced.seas <<- lm(sw.notrend ~ months - 1)
# evaluate harmonic seasonality
# create an empty matrix
SIN <<- COS <<-  matrix(nrow = length(time), ncol = 6)# 6 = freq/2
# loop through
for(i in 1:6){
SIN[,i] <- sin(2*pi*i*time)
COS[,i] <- cos(2*pi*i*time)
}
# model all season harmonic
# model notrend against all values with -1
slice.har1 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1], COS = COS[,1]))
# slice 2
slice.har2 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:2], COS = COS[,1:2]))
# slice 3
slice.har3 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:3], COS = COS[,1:3]))
# slice 4
slice.har4 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:4], COS = COS[,1:4]))
# slice 5
slice.har5 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:5], COS = COS[,1:5]))
# slice 6
slice.har6 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:6], COS = COS[,1:6]))
}
# run seasonality fun
get.seasonality(slicedWindow)
getAIC <- data.frame(
slice.har.1 = AIC(slice.har1),
slice.har.2 = AIC(slice.har2),
slice.har.3 = AIC(slice.har3),
slice.har.4 = AIC(slice.har4),
slice.har.5 = AIC(slice.har5),
slice.har.6 = AIC(slice.har6)
)
# print with knitr table
kable(getAIC, caption = "AIC's for all harmonic seasonalities")
# sort decreasing
getAIC %>% sort(decreasing = F)
summary(slice.har1)
summary(slice.har2)
summary(slice.har3)
summary(slice.har4)
summary(slice.har5)
summary(slice.har6)
# removed as it doesnt work.
# plot(slicedWindow,
#      main = "AVG TEMPS IN UK",
#      xlab = "Year",
#      ylab = "AVG TEMP",
#      type = "l")
# lines doesnt work for some reason.
# lines(time,
#       fitted(slice.har2),
#       lwd = 3,
#       type = "l",
#       col = "blue")
# find max value
colMax <- function(data) sapply(data, max, na.rm = TRUE)
getAIC <- data.frame(
TMAX.Top = (colMax(Data$Tmax) %>% which.max()),
# East_Anglia has the highest temp within the Tmax series
TMEAN.Top = (colMax(Data$Tmean) %>% which.max()),
# East_Anglia has the highest temp within the Tmean series.
TMIN.Top(colMax(Data$Tmin) %>% which.max())
# England_SE_and_Central_S has the highest temp within Tmin.
)
# find max value
colMax <- function(data) sapply(data, max, na.rm = TRUE)
# put into a df
top.temps <- data.frame(
TMAX.Top  = (colMax(Data$Tmax) %>% which.max()),
TMEAN.Top = (colMax(Data$Tmean) %>% which.max()),
TMIN.Top  = (colMax(Data$Tmin) %>% which.max())
)
# print with knitr table (kable)
kable(top.temps, caption = "AIC's for all harmonic seasonalities")
colMax(Data$Tmax) %>% which.max()
# East_Anglia has the highest temp within the Tmax series
colMax(Data$Tmean) %>% which.max()
# East_Anglia has the highest temp within the Tmean series.
colMax(Data$Tmin) %>% which.max()
# England_SE_and_Central_S has the highest temp within Tmin.
colMin(Data$Tmax) %>% which.min()
# find lowest value
colMin <- function(data) sapply(data, min, na.rm = TRUE)
colMin(Data$Tmax) %>% which.min()
# Midlands has the lowest temp within the Tmax series.
colMin(Data$Tmean) %>% which.min()
# Scotland_E has the lowest temp within the Tmean series.
colMin(Data$Tmin) %>% which.min()
# Scotland_E has the lowest temp within the Tmin series
# The above can also be done on the full dataset.
maxTemps <- sapply(Data, colMax)
minTemps <- sapply(Data, colMin)
totRange <- sapply(Data, colRange)
# create df
allTemps <- data.frame(
max.temps = maxTemps,
min.temps = minTemps,
tot.range = totRange
)
# print with knitr table
kable(allTemps, caption = "AIC's for all harmonic seasonalities")
maxTemps
minTemps
totRange
# The above can also be done on the full dataset.
maxTemps <- sapply(Data, colMax)
minTemps <- sapply(Data, colMin)
totRange <- sapply(Data, colRange)
maxTemps
minTemps
totRange
colAvg <- function(data) sapply(data, mean)
sapply(Data, colAvg)
## NONE OF THIS WORKS
# Time Series function
convert.ts <- function(data, feature, district){ # pass 3 parameters
c(data, feature, districts) %>%
paste(collapse = "$") # add $ between each parameter
}
matrix.ts <- function(feature){
lapply(data, convert.ts, feature = feature, district = districts)
}
tsMatrix <- matrix.ts(Data)
matCon <- function(data){
data %>%
t() %>%
as.vector()
}
testTS <- lapply(Data, matCon)
is.vector(testTS)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# function to slice dataset
slice.ts <- function(data){
data %>% window(start = c(1884,12),
end = c(2019,12),
frequency = 12,
extend = FALSE)
}
# use fun for each dataset.
slicedWindow <-
slice.ts(Data$Tmax$England_SE_and_Central_S)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# function to slice dataset
slice.ts <- function(data){
data %>% window(start = c(1884,12),
end = c(2019,12),
frequency = 12,
extend = FALSE)
}
# use fun for each dataset.
slicedWindow <-
slice.ts(Data$Tmax$England_SE_and_Central_S)
# 4.1 - Estimate Trend
# Estimate the trend of each time series using linear, quadratic and cubic
# regression. Compare your results and use appropriate plots and/or tables
# to confirm your observations.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# create time vector
# create a time vector
time <- 1:length(slicedWindow)
# re-scale from 0 - 1
time <- (time - min(time))/(max(time) - 1)
# function for linear model
linear.fun <- function(timeseries){
# create linear trend
linear.fit <<- lm(timeseries ~ time) # use <<- for global variables
# create linear fitted
linear.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->> linear.fitted
}
# run linear fun
linear.fun(slicedWindow)
# check summary
summary(linear.fit)
# Now try to plot
ts.plot(slicedWindow, ylab = "Temperature")
# add linear fitted lines
lines(linear.fitted, col = "green", lwd = 2)
# add mean line
abline(mean(slicedWindow), 0, col = "blue", lwd = 2)
# temp is very slowly increasing.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# square the time
time2 <- (time^2)
# quadratic trend
quadratic.fun <- function(timeseries){
# create quadratic fit model
quadratic.fit <<- lm(timeseries ~ time + time2)
# create quadratic fitted
quadratic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run quad function
quadratic.fun(slicedWindow)
# check summary
summary(quadratic.fit)
# add linear fitted lines
lines(quadratic.fitted, col = "green", lwd = 2)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# cube time
time3 <- time^3
# cubic function
cube.fun <- function(timeseries){
# create cubic fit model
cubic.fit <<- lm(timeseries ~ time + time2 + time3)
# create cubic fitted
cubic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run cubic function
cube.fun(slicedWindow)
# check summary
summary(cubic.fit)
# add cubic line
lines(time,
cubic.fit %>% fitted(),
col = 'yellow',
lwd = 3)
# check fit
AIC(linear.fit)
AIC(quadratic.fit)
AIC(cubic.fit)
# 4.3 - Estimate Seasonality
# After removing the trend using the model selected in the previous step,
# use the output to estimate the seasonality of each time series employing averaging and sine-cosine models.
# Compare your results and use appropriate plots and/or tables to confirm your observations.
get.seasonality <- function(timeseries){
# get the residuals
sw.notrend <<- (timeseries - fitted(linear.fit))
# get seasonal means
tapply(sw.notrend, cycle(sw.notrend), mean)
# create months variable as factor
months <- sw.notrend %>% cycle() %>% as.factor()
# seasonal means
sliced.seas <<- lm(sw.notrend ~ months - 1)
# evaluate harmonic seasonality
# create an empty matrix
SIN <<- COS <<-  matrix(nrow = length(time), ncol = 6)# 6 = freq/2
# loop through
for(i in 1:6){
SIN[,i] <- sin(2*pi*i*time)
COS[,i] <- cos(2*pi*i*time)
}
# model all season harmonic
# model notrend against all values with -1
slice.har1 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1], COS = COS[,1]))
# slice 2
slice.har2 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:2], COS = COS[,1:2]))
# slice 3
slice.har3 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:3], COS = COS[,1:3]))
# slice 4
slice.har4 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:4], COS = COS[,1:4]))
# slice 5
slice.har5 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:5], COS = COS[,1:5]))
# slice 6
slice.har6 <<- lm(sw.notrend ~ . -1 ,
data.frame(SIN = SIN[,1:6], COS = COS[,1:6]))
}
# run seasonality fun
get.seasonality(slicedWindow)
getAIC <- data.frame(
slice.har.1 = AIC(slice.har1),
slice.har.2 = AIC(slice.har2),
slice.har.3 = AIC(slice.har3),
slice.har.4 = AIC(slice.har4),
slice.har.5 = AIC(slice.har5),
slice.har.6 = AIC(slice.har6)
)
# print with knitr table
kable(getAIC, caption = "AIC's for all harmonic seasonalities")
# sort decreasing
getAIC %>% sort(decreasing = F)
#summary(slice.har1)
#summary(slice.har2)
#summary(slice.har3)
#summary(slice.har4)
#summary(slice.har5)
#summary(slice.har6)
# removed as it doesnt work.
# plot(slicedWindow,
#      main = "AVG TEMPS IN UK",
#      xlab = "Year",
#      ylab = "AVG TEMP",
#      type = "l")
# lines doesnt work for some reason.
# lines(time,
#       fitted(slice.har2),
#       lwd = 3,
#       type = "l",
#       col = "blue")
Data$Tmax$Northern_Ireland %>% head()
# find max value
colMax <- function(data) sapply(data, max, na.rm = TRUE)
colMax(Data$Tmax) %>% which.max()
# East_Anglia has the highest temp within the Tmax series
colMax(Data$Tmean) %>% which.max()
# East_Anglia has the highest temp within the Tmean series.
colMax(Data$Tmin) %>% which.max()
# England_SE_and_Central_S has the highest temp within Tmin.
maxTemps
minTemps
```{r}
totRange
colAvg <- function(data) sapply(data, mean)
sapply(Data, colAvg)
# check fit
AIC(linear.fit)
AIC(quadratic.fit)
AIC(cubic.fit)
# 4.1 - Estimate Trend
# Estimate the trend of each time series using linear, quadratic and cubic
# regression. Compare your results and use appropriate plots and/or tables
# to confirm your observations.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# create time vector
# create a time vector
time <- 1:length(slicedWindow)
# re-scale from 0 - 1
time <- (time - min(time))/(max(time) - 1)
# function for linear model
linear.fun <- function(timeseries){
# create linear trend
linear.fit <<- lm(timeseries ~ time) # use <<- for global variables
# create linear fitted
linear.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->> linear.fitted
}
# run linear fun
linear.fun(slicedWindow)
# check summary
summary(linear.fit)
# Now try to plot
ts.plot(slicedWindow, ylab = "Temperature")
# add linear fitted lines
lines(linear.fitted, col = "green", lwd = 2)
# add mean line
abline(mean(slicedWindow), 0, col = "blue", lwd = 2)
# temp is very slowly increasing.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# square the time
time2 <- (time^2)
# quadratic trend
quadratic.fun <- function(timeseries){
# create quadratic fit model
quadratic.fit <<- lm(timeseries ~ time + time2)
# create quadratic fitted
quadratic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run quad function
quadratic.fun(slicedWindow)
# check summary
summary(quadratic.fit)
# add linear fitted lines
lines(quadratic.fitted, col = "green", lwd = 2)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# cube time
time3 <- time^3
# cubic function
cube.fun <- function(timeseries){
# create cubic fit model
cubic.fit <<- lm(timeseries ~ time + time2 + time3)
# create cubic fitted
cubic.fit %>% fitted() %>% ts(start = c(1884,12), end = c(2019,12), frequency = 12) ->>
quadratic.fitted
}
# run cubic function
cube.fun(slicedWindow)
# check summary
summary(cubic.fit)
# add cubic line
lines(time,
cubic.fit %>% fitted(),
col = 'yellow',
lwd = 3)
